---
title: ☠️ Как в Ansible делать нельзя
id: bad-ansible
sidebar_position: 1
---

Прочитав статью, основанную на выступлении Георгия Шуклина, про худшие практики в Ansible, я решил дополнительно записать их на этом сайте. Собственно, поехали. 

:::info 
Сама статья и выступление доступны по этой ссылке https://habr.com/ru/articles/536256/.
:::

## Хороший Ansible

Хороший Ansible – это тот, который идет и делает то, что сказали. Он не думает, он не пытается принимать какие-то решения за пределами специфики конфигурации сервера.

- Простая автоматизация
- Отсутствие бизнес-логики
- Отсутствие алгоритмов
- Вынос принятия решения за внешние сущности
- Простота чтения кода

## Плохой Ansible

Усилия будут очень героические, а результаты будут еще хуже, чем, когда вы начали.

- Сложная автоматизация
- Бизнес логика
- Алгоритмы!
- Принятия решений внутри ролей и шаблонов
- Сложный для понимания код

## Плохие практики

### (args*, kwargs**)-синдром

Думать, что чем больше переменных, тем лучше – ошибка.

Антипаттерн замечается, когда вы читаете код на Ansible, и вы постоянно вынуждены прыгать по различным файлам.

### Нарушение идемпотентности на входе

Идемпотентность на входе означает, что вы можете снова и снова исполнять один и тот же play.

:::info Пример
```yml
- command: mv /etc/foo /etc/foo.old
```
:::

### Нарушение идемпотентности на выходе

Нарушение идемпотентности на выходе позволяет Ansible работать, но ломает или ухудшает ситуацию в системе.

Например, если мы сделаем себе файл и попытаемся его перезаписать еще раз, то мы можем обнаружить, что, когда следующей задачей в него что-то записали, она его стерла.

:::info Пример
```yml
- lineinfile: path=/etc/foo line=foo insertafter=EOF
```
:::

### Сломанные --tags

Теги нужны в Ansible для того, чтобы оператор мог выполнить кусок playbook и только. Они не используются ни для аннотации, они не используются ни для каких магических операций.

:::info Пример
Тег не работает, потому что мы зависим от предыдущей задачи, в которой тега нет.
```yml
- uri: 
    url: http://example.com/foo_name
  register: foo_result
- command: 'update {{ foo_result.json.name }}'
  tags:
    - update_foo
```
:::

### Разбегание тегов 

Аналогичная проблема возникает вот здесь, когда мы в процессе письма начинаем использовать синонимы в тегах.

В больших проектах наблюдается часто разбегание знака подчеркивания, без знака подчеркивания, тега с префиксом, тега без префикса, тега на всякий случай, авось кому-то пригодится. Ничего этого не должно быть.

:::info Пример
Не существует никакого метода выполнить эти две роли с помощью одного тега.

```yml
role1:
  - apt: name=foo
    tags:
      - install
      - packages
  - apt: name=bar
    tags: 
      - apt
      - installation
```
:::

### Ошибки в расположении переменных

Когда люди обнаруживают, что им нужно сконфигурировать несколько несвязанных сервисов на нескольких несвязанных серверах с использованием одной некой магической переменной, которую не хочется отдавать в inventory, они начинают думать, куда разместить эту переменную.

Единственное правильное место, где эта переменная должна быть – в playbook, который объединяет конфигурацию этих двух серверов.

Если вы положите в групповые переменные, в дефолтные предварительно подключающиеся роли, то это все ухудшит ситуацию.

### Река лавы

Антипаттерн сводится к тому, что люди начинают писать большой кусок кода. И понимают, что они могут написать лучше. Придумывают, как писать лучше. Продолжают писать лучше. К тому времени, как заканчивают писать лучше, они пишут еще лучше. И следующие роли они пишут еще лучше. И весь проект состоит из бесконечных слоев все больше хорошего кода, при этом старый код остается в том виде, в каком он был, полагаясь на ошибочные предположения, неправильное расположение переменных и т. д.

Бороться с таким паттерном можно только одним образом – не умничать с применением новых решений. Лучше держаться одного стиля в течение одного проекта, чем постоянно экспериментировать с новыми стилями.

### Шаблонизация YAML и JSON

Jinja и YAML не совместимы в том смысле, что вы никогда не сможете сгенерировать хороший YAML с помощью циклов в подстановке переменных и других ужасов Jinja. Вместо этого нужно взять структуру данных, которую вы хотите записать в JSON или в YAML и записать с помощью фильтра to_nice_yaml.

### Coupling

Это ситуация, когда один кусок программного обеспечения полагается на детали реализации внутри другого куска программного обеспечения.

Ansible не предоставляет возможности уменьшать coupling. Не существует инструмента внутри, с помощью которого вы можете уменьшить степень связанности в вашем проекте.

Единственный метод – поддерживание дисциплину в голове

#### Общий include для ролей

Эта относительно невинная ошибка создает зависимости роли 1 от роли 2 и наоборот, потому что роль 2 не знает, кто будет использовать этот файл. И в момент рефакторинга роли 2, если мы вот сюда внесем изменения, мы сломаем роли. Не существует механизма, с помощью которого, глядя вот сюда, можно понять, что мы ломаем роль 2.

:::info Пример
```yml title="role1/tasks/main.yml"
- include_tasks: common.yml
```
```yml title="role2/tasks/main.yml"
- include_tasks: common.yml
```
```yml title="common.yml"
- debug: msg="sad days befall"
```
:::

#### Доступ к инвентори из ролей и шаблонов

Когда мы берём шаблон и начинаем шариться в группах и переменных соседних хостов – **это почти фатальная ошибка**. Проект, в котором такое появляется, обречён на тяжелый рефакторинг.

Решается указанием всех нужных параметров в виде переменных на уровне playbook'а.

:::info Пример
```j2 title="roles/role1/templates/foo.conf.j2"
  {% for h in groups.foo %}
    {% for x in hostvars[h].data %}
      {{ h }} {{ x.foo }}
    {% endfor %}
  {% endfor %}
```
:::

#### Делегация на фиксированный хост

Проблема – роль полезла в inventory.

Роль никогда не должна трогать объекты из inventory, которые не относятся к переменным, которые доступны сами по себе. Как только мы лезем в hostvars из роли, мы делаем что-то не так. Как только мы упоминаем имя хоста, мы делаем что-то не так.

Решается указанием имени хоста, куда надо делегировать в виде переменной на уровне play.

:::info Пример
```yml
- delegate_to: host2
  command: die, please
  args:
    creates: /body.dump
  when: foo.should.die is defined
```
:::

#### Коллизия имён переменных между ролями

Проблема, к сожалению, не имеет решения в Ansible. Это случайные коллизии между именами переменных.

Если роль в одной части проекта выставила значение переменной, в силу перекрытия (shadowing) переменных вот это значение может прилететь в другую роль.

Случайное выставление vars в одном месте может поменять значение для другой роли.

Тоже самое касается set_facts, которые могут случайно затереть чужой default. В Ansible нет механизмов, которые позволяют такие вещи обнаружить.

Единственный метод с этим бороться – это дисциплина в проекте, именование переменных и все.

:::info Пример
```yml title="roles/role1/tasks/main.yml"
- command: 'do {{ foo }}'
```
```yml title="roles/role2/vars/main.yml"
- foo: 'need in role 2'
```
```yml title="site.yml"
roles: [role1, role2]
vars: { foo: 1 }
```
:::

## Личные советы Шуклина

### DRY is dead

Не нужно бороться за компактность кода. Куда лучше написать 200 строк копи-пастом с небольшими изменениями, чем пытаться быть очень умным и использовать несколько includes. Как только вы используете несколько includes, вы вступаете в сложную область видимости переменных.

Существует несколько ошеломительных случаев, когда роль может быть доступна из одного слоя, а значения будут уходить в другой слой. Т. е. роль получает на входе переменную значением 2, говорит: «Я эту переменную выставляю в 3», роль продолжает видеть значение 2. И далее роль заканчивается, следующая за этой ролью получает значение 3.

Проблема с любыми includes, import состоит в том, что вы никогда не знаете, как не надо делать. Вы об этом узнаете потом, после специального тест-кейса.

### no pure function

Никаких чистых функций. Соответственно, если у вас нет чистых функций, вы не можете реализовать бизнес-логику. Чем меньше вы принимаете решений в коде, тем лучше.

В Ansible есть единственная вещь, на которую можно всерьез положиться и ожидать, что она будет исполняться хорошо, **это порядок исполнения тасок**.

Как только вы пытаетесь это изменить с помощью дополнительных условий, циклов, импортов, includes вы обнаруживаете, что проект становится менее устойчивым, потому что Ansible хорошо делает линейное исполнение кода.

### No tooling for coupling reduction

Механизмов уменьшения связностей нет никаких.

Единственный метод уменьшить связностей в проекте Ansible – разделить его на 2 playbooks и запускать в 2 раздельных запуска Ansible. Потому что в любой момент любая самая маленькая роль где-то в углу может пойти и поменять критически важную переменную для другого участка кода. Соответственно, это требует особой дисциплины.

## Что если всё таки необходимо тащить бизнес-логику в Ansible?

Ответ – использовать внешние инструментарии.

Внешние инструментарии можно использовать двумя разными образами:
- Внешний инструментарий может подготовить все для запуска Ansible, принять за него решение и записать, что нужно сделать.
- Ansible может прийти к внешнему проекту и попросить принять решение.

Издалека кажется, что это практически одно и то же, но на самом деле есть большая разница.

Когда кто-то подготовил данные для Ansible и запустил его, то у вас есть эти данные, вы можете повторить попытку, если что-то пошло не так.

Если же Ansible пошел за данными в реальном времени по http, то вы не можете воспроизвести эту ситуацию, потому что вы оказываетесь завязаны на логику внешнего сервиса, который вы не можете воспроизвести на своей машине.

В то же самое время, если у вас есть сгенерированные файлы, с которыми Ansible запускается, то вы можете повторить снова и снова до тех пор, пока не найдете место, где ошибка.